<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Shake! Shake!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300&family=Noto+Serif+JP:wght@200;300&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #030305;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Inter', 'Noto Serif JP', serif;
            color: white;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            filter: contrast(1.1) brightness(1.2);
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            z-index: 50;
            padding: 8px 8px 8px 20px;
            transition: all 0.4s cubic-bezier(0.2, 1, 0.3, 1);
        }

        /* モバイルで入力中にUIを少し上げる */
        .ui-overlay.focused {
            top: 10px;
            background: rgba(255, 255, 255, 0.08);
        }

        .volume-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 60;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 6px 14px;
            border-radius: 100px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 60px;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: white;
            margin-top: -5px;
        }

        #permission-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 16px 40px;
            background: transparent;
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 100px;
            font-weight: 200;
            letter-spacing: 0.3em;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        @media (hover: hover) {
            #permission-btn:hover {
                background: white;
                color: black;
            }
        }

        #permission-btn:active {
            transform: translate(-50%, -50%) scale(0.95);
            background: rgba(255,255,255,0.1);
        }

        input[type="text"] {
            background: transparent;
            border: none;
            color: white;
            font-size: 16px; /* モバイルでズームされないための最小サイズ */
            font-weight: 200;
            width: 100%;
        }

        input[type="text"]:focus {
            outline: none;
        }

        .glow-dot {
            position: absolute;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(120, 150, 255, 0.05) 0%, rgba(0,0,0,0) 70%);
            pointer-events: none;
            z-index: -1;
            transition: transform 0.1s ease-out;
        }
    </style>
</head>
<body>

    <div class="glow-dot" id="cursor-glow"></div>
    <button id="permission-btn">TAP TO START</button>

    <div class="ui-overlay glass-panel" id="ui-container" style="display: none; opacity: 0;">
        <div class="flex items-center gap-3">
            <input type="text" id="typo-input" placeholder="Say something..." autocomplete="off">
            <button id="add-btn" class="bg-white text-black w-9 h-9 rounded-full flex items-center justify-center shrink-0 shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </button>
        </div>
        <div class="mt-2 flex justify-between items-center opacity-40 px-1 pointer-events-none">
            <span class="text-[8px] uppercase tracking-[0.2em] font-light">Tilt to drift • Shake to burst</span>
            <span id="obj-count" class="text-[8px] font-light">0 ELEMENTS</span>
        </div>
    </div>

    <div class="volume-control" id="volume-container" style="display: none; opacity: 0;">
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="opacity-50"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.3">
    </div>

    <script>
        const { Engine, Render, Runner, Bodies, Composite, Vector, Body, Events } = Matter;

        let engine, render, runner;
        let audioCtx, delayNode, feedbackNode, masterGain, mainFilter;
        let isStarted = false;
        let walls = {};
        
        const textureCache = {};
        const MAX_BODIES = 80; // モバイル向けに少し制限
        const MAX_SOUNDS = 15;
        let activeSounds = 0;

        const NOTE_TABLE = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };

        async function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;

            delayNode = audioCtx.createDelay(1.0);
            delayNode.delayTime.value = 0.4;

            feedbackNode = audioCtx.createGain();
            feedbackNode.gain.value = 0.5;

            mainFilter = audioCtx.createBiquadFilter();
            mainFilter.type = 'lowpass';
            mainFilter.frequency.value = 2200;

            delayNode.connect(feedbackNode);
            feedbackNode.connect(mainFilter);
            mainFilter.connect(delayNode);
            delayNode.connect(masterGain);
            masterGain.connect(audioCtx.destination);
        }

        function playCrystalSound(frequency, volume = 0.1, decay = 1.0, isNote = false) {
            if (!audioCtx || activeSounds >= MAX_SOUNDS) return;
            
            activeSounds++;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            
            osc.type = isNote ? 'sine' : 'triangle';
            osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.02);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + decay);
            
            osc.connect(g);
            g.connect(delayNode);
            g.connect(masterGain);
            
            osc.start();
            osc.stop(audioCtx.currentTime + decay + 0.1);
            osc.onended = () => { activeSounds--; };
        }

        function createWalls() {
            const thickness = 100;
            const w = window.innerWidth;
            const h = window.innerHeight;

            if (Object.keys(walls).length > 0) Composite.remove(engine.world, Object.values(walls));

            const options = { isStatic: true, friction: 0.1, restitution: 0.6 };
            walls.top = Bodies.rectangle(w / 2, -thickness / 2, w, thickness, options);
            walls.bottom = Bodies.rectangle(w / 2, h + thickness / 2, w, thickness, options);
            walls.left = Bodies.rectangle(-thickness / 2, h / 2, thickness, h, options);
            walls.right = Bodies.rectangle(w + thickness / 2, h / 2, thickness, h, options);

            Composite.add(engine.world, Object.values(walls));
        }

        function initPhysics() {
            engine = Engine.create();
            engine.gravity.y = 1.0;

            render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: 'transparent',
                    pixelRatio: window.devicePixelRatio > 1 ? 2 : 1
                }
            });

            createWalls();
            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach(pair => {
                    const body = pair.bodyA.charFreq ? pair.bodyA : (pair.bodyB.charFreq ? pair.bodyB : null);
                    const speed = pair.bodyA.speed + pair.bodyB.speed;
                    if (body && speed > 5) {
                        playCrystalSound(body.charFreq * 1.2, 0.015 * (speed / 8), 0.5, body.isNote);
                    }
                });
            });

            const trigger = (x, y) => { explode(x, y); createRipple(x, y); };
            window.addEventListener('mousedown', (e) => { 
                if(e.target.tagName === 'CANVAS') trigger(e.clientX, e.clientY); 
            });
            window.addEventListener('touchstart', (e) => { 
                if(e.target.tagName === 'CANVAS') trigger(e.touches[0].clientX, e.touches[0].clientY); 
            }, {passive: true});
        }

        function createTextTexture(char, isNote) {
            const cacheKey = char + (isNote ? '_n' : '_t');
            if (textureCache[cacheKey]) return textureCache[cacheKey];

            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = isNote ? '#fff' : 'rgba(255,255,255,0.75)';
            ctx.font = `200 60px "Inter", "Noto Serif JP", serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (isNote) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(255,255,255,0.4)";
            }
            ctx.fillText(char, size/2, size/2);
            
            const url = canvas.toDataURL();
            textureCache[cacheKey] = url;
            return url;
        }

        function addTypo(text) {
            if (!text) return;
            const chars = text.split('');
            chars.forEach((char, i) => {
                setTimeout(() => {
                    const bodies = Composite.allBodies(engine.world).filter(b => !b.isStatic);
                    if (bodies.length >= MAX_BODIES) Composite.remove(engine.world, bodies[0]);

                    const x = window.innerWidth / 2 + (Math.random() - 0.5) * 40;
                    const y = 80;
                    const isNote = NOTE_TABLE[char.toUpperCase()] !== undefined;
                    const freq = isNote ? 440 * Math.pow(2, (NOTE_TABLE[char.toUpperCase()] - 9) / 12) : 200 + (char.charCodeAt(0) % 400);
                    
                    const box = Bodies.circle(x, y, isNote ? 26 : 22, {
                        friction: 0.05,
                        restitution: 0.8,
                        render: {
                            sprite: {
                                texture: createTextTexture(char, isNote),
                                xScale: 0.5, yScale: 0.5
                            }
                        }
                    });
                    
                    box.charFreq = freq;
                    box.isNote = isNote;
                    Composite.add(engine.world, box);
                    updateCount();
                    playCrystalSound(freq, isNote ? 0.25 : 0.15, 1.2, isNote);
                }, i * 100);
            });
        }

        function explode(x, y) {
            const bodies = Composite.allBodies(engine.world);
            bodies.forEach(body => {
                if (body.isStatic) return;
                const d = Vector.sub(body.position, { x, y });
                const dist = Vector.magnitude(d);
                if (dist < 300) {
                    const force = 0.02 * (1 - dist / 300);
                    Body.applyForce(body, body.position, Vector.mult(Vector.normalise(d), force));
                }
            });
            playCrystalSound(150, 0.1, 0.8);
        }

        function createRipple(x, y) {
            const r = document.createElement('div');
            r.className = 'fixed rounded-full pointer-events-none border border-white/20';
            r.style.left = x + 'px'; r.style.top = y + 'px';
            r.style.width = '0px'; r.style.height = '0px';
            r.style.transform = 'translate(-50%, -50%)';
            r.style.transition = 'all 1s cubic-bezier(0.1, 1, 0.2, 1)';
            document.body.appendChild(r);
            requestAnimationFrame(() => {
                r.style.width = '400px'; r.style.height = '400px';
                r.style.opacity = '0';
            });
            setTimeout(() => r.remove(), 1000);
        }

        function updateCount() {
            const count = Composite.allBodies(engine.world).filter(b => !b.isStatic).length;
            document.getElementById('obj-count').innerText = `${count} ELEMENTS`;
        }

        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity;
            if (!acc) return;
            
            // iOSとAndroidの正規化（iOSは正負が逆転しやすい）
            let gx = acc.x / 10;
            let gy = acc.y / 10;
            
            // 端末の向きに合わせて重力を調整
            if (window.orientation === 90) {
                engine.gravity.x = -gy;
                engine.gravity.y = -gx;
            } else if (window.orientation === -90) {
                engine.gravity.x = gy;
                engine.gravity.y = gx;
            } else {
                engine.gravity.x = -gx;
                engine.gravity.y = gy;
            }

            const shake = event.acceleration;
            if (shake && (Math.abs(shake.x) > 20 || Math.abs(shake.y) > 20)) {
                explode(window.innerWidth / 2, window.innerHeight / 2);
            }
        }

        const startBtn = document.getElementById('permission-btn');
        const uiContainer = document.getElementById('ui-container');
        const volContainer = document.getElementById('volume-container');
        const input = document.getElementById('typo-input');
        const addBtn = document.getElementById('add-btn');
        const volSlider = document.getElementById('volume-slider');
        const cursorGlow = document.getElementById('cursor-glow');

        window.addEventListener('mousemove', (e) => {
            cursorGlow.style.transform = `translate(${e.clientX - 200}px, ${e.clientY - 200}px)`;
        });

        volSlider.addEventListener('input', (e) => {
            if (masterGain) masterGain.gain.value = e.target.value;
        });

        input.addEventListener('focus', () => uiContainer.classList.add('focused'));
        input.addEventListener('blur', () => uiContainer.classList.remove('focused'));

        startBtn.addEventListener('click', async () => {
            if (isStarted) return;
            isStarted = true;
            await initAudio();
            initPhysics();
            
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceMotionEvent.requestPermission();
                    if (response === 'granted') window.addEventListener('devicemotion', handleMotion);
                } catch (e) { console.error(e); }
            } else {
                window.addEventListener('devicemotion', handleMotion);
            }

            startBtn.style.opacity = '0';
            setTimeout(() => {
                startBtn.style.display = 'none';
                uiContainer.style.display = 'block';
                volContainer.style.display = 'flex';
                setTimeout(() => {
                    uiContainer.style.opacity = '1';
                    volContainer.style.opacity = '1';
                }, 50);
                addTypo("flow");
            }, 500);
        });

        addBtn.addEventListener('click', () => { 
            if (!input.value.trim()) return;
            addTypo(input.value); 
            input.value = ''; 
            input.blur(); // 入力後にキーボードを閉じる（モバイル体験向上）
        });
        
        input.addEventListener('keypress', (e) => { if (e.key === 'Enter') addBtn.click(); });
        
        // リサイズ時の安定化
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                if (!render) return;
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
                createWalls();
            }, 250);
        });

    </script>
</body>
</html>
